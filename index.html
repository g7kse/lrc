<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#3b4b59">
  <meta name="description" content="Lakeland Rowing Club Weather">
  <title>Derwentwater Weather</title>
  <link rel="manifest" href="/manifest.json">
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'IBM Plex Mono', monospace;
      background-color: #12437bff;
      color: #e1e4e1;
      height: 100vh;
      overflow: hidden;
      padding: 4px;
      display: flex;
      flex-direction: column;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    
    .header {
      text-align: center;
      margin-bottom: 12px;
      flex-shrink: 0;
    }
    
    .logo {
      width: 140px;
      height: auto;
      margin: 0 auto 6px;
      display: block;
    }
    
    h1 {
      font-size: 1.5rem;
      font-weight: 700;
      margin-bottom: 8px;
    }
    
    input {
      flex: 1;
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid #4a5a69;
      background-color: #aac6d2ff;
      color: #e1e4e1;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.875rem;
    }
    
    input::placeholder {
      color: #8a9aa9;
    }
    
    input:focus {
      outline: none;
      border-color: #6a7a89;
    }
    
    button {
      padding: 8px 16px;
      background-color: #aac6d2ff;
      color: #050505;
      border: none;
      border-radius: 6px;
      font-family: 'IBM Plex Mono', monospace;
      font-weight: 600;
      cursor: pointer;
      font-size: 0.875rem;
    }
    
    button:hover {
      opacity: 0.8;
    }
    
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .error {
      margin-top: 4px;
      padding: 4px 12px;
      background-color: #5a3b3b;
      color: #ffb3b3;
      border-radius: 6px;
      display: inline-block;
      font-size: 0.75rem;
    }
    
    .weather-container {
      background-color: #aac6d2ff;
      border-radius: 10px;
      padding: 8px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
      margin-bottom: 6px;
    }
    
    .current-weather {
      background-color: #aac6d2ff;
      color: #000000;
      border-radius: 8px;
      padding: 8px;
      margin-bottom: 8px;
      flex-shrink: 0;
    }
    
    .location {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
    }
    
    .location h2 {
      font-size: 1rem;
      font-weight: 700;
    }
    
    .conditions-banner {
      padding: 8px 8px;
      border-radius: 8px;
      font-size: 0.9rem;
      font-weight: 700;
      text-align: center;
      margin-bottom: 8px;
      flex-shrink: 0;
    }
    
    .conditions-great {
      background-color: #2d5f2d;
      color: #90ee90;
    }
    
    .conditions-good {
      background-color: #4a5f2d;
      color: #c8e690;
    }
    
    .conditions-reasonable {
      background-color: #5f5f2d;
      color: #ffff90;
    }
    
    .conditions-marginal {
      background-color: #5f3d2d;
      color: #ffb380;
    }
    
    .conditions-bad {
      background-color: #5f2d2d;
      color: #ff9090;
    }
    
    .current-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
    }
    
    .metric {
      text-align: center;
    }
    
    .metric-icon {
      width: 20px;
      height: 20px;
      margin: 0 auto 4px;
    }
    
    .metric-label {
      font-size: 0.625rem;
      opacity: 0.8;
      margin-bottom: 2px;
    }
    
    .metric-value {
      font-size: 1rem;
      font-weight: 700;
    }
    
    .metric-sub {
      font-size: 0.625rem;
      opacity: 0.7;
      margin-top: 2px;
    }
    
    .forecast-header {
      font-size: 0.8rem;
      color: #000000;
      font-weight: 700;
      margin-bottom: 6px;
      flex-shrink: 0;
    }
    
    .forecast-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 2px;
      flex: 1;
      align-content: start;
    }

    /* Header layout for location + embedded conditions banner */
    .current-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }

    #conditionsBanner { display:flex; align-items:center; }
    
    .forecast-day {
      background-color: #12437bff;
      border-radius: 6px;
      padding: 4px 2px;
      text-align: center;
    }
    
    .day-name {
      font-weight: 600;
      font-size: 0.625rem;
      margin-bottom: 2px;
    }
    
    .day-date {
      font-size: 0.5rem;
      opacity: 0.8;
      margin-bottom: 4px;
    }
    
    .day-temp {
      font-size: 1.125rem;
      font-weight: 700;
      margin-bottom: 4px;
    }
    
    .day-detail {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 2px;
      font-size: 0.5rem;
      margin-bottom: 2px;
    }
    
    .day-detail svg {
      width: 10px;
      height: 10px;
    }
    
    .empty-state {
      text-align: center;
      margin-top: 48px;
    }
    
    .empty-icon {
      width: 80px;
      height: 80px;
      margin: 0 auto 16px;
      opacity: 0.5;
    }
    
    .empty-text {
      font-size: 1.25rem;
      opacity: 0.8;
    }
    
    .install-prompt {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #4a5a69;
      padding: 16px 24px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      display: none;
      align-items: center;
      gap: 16px;
      max-width: 90%;
      z-index: 1000;
    }
    
    .install-prompt.show {
      display: flex;
    }
    
    .install-prompt button {
      white-space: nowrap;
    }
    
    @media (max-width: 768px) {
      .logo {
        width: 60px;
      }
      
      h1 {
        font-size: 1.25rem;
      }
      
      .current-grid {
        grid-template-columns: repeat(4, 1fr);
        gap: 6px;
      }
      
      .metric-value {
        font-size: 1rem;
      }
      
      .metric-icon {
        width: 16px;
        height: 16px;
      }
      
      .forecast-grid {
        gap: 3px;
      }
      
      .forecast-day {
        padding: 4px 2px;
      }
      
      .day-temp {
        font-size: 1rem;
      }

      /* Stack header and banner on small screens */
      .current-header {
        flex-direction: column;
        align-items: flex-start;
      }

      #conditionsBanner {
        width: 100%;
        margin-top: 8px;
        justify-content: flex-start;
      }

      .conditions-banner {
        min-width: auto;
        width: 100%;
      }

      .forecast-grid {
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 6px;
        overflow-x: auto;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <img src="/icons/lrc_logo.png" alt="Lakeland Rowing Club Logo" class="logo">
    </div>
    
    <div id="weatherContainer"></div>
    <div id="emptyState" class="empty-state" style="display: none;">
      <svg class="empty-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 15a4 4 0 004 4h9a5 5 0 10-.1-9.999 5.002 5.002 0 10-9.78 2.096A4.001 4.001 0 003 15z"></path>
      </svg>
      <p class="empty-text">Loading weather...</p>
    </div>
  </div>
  
  <!-- Chart.js and annotation plugin -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.1.1/dist/chartjs-plugin-annotation.min.js"></script>

 <script>
    let deferredPrompt;
    let weatherData = null;
    let selectedDayIndex = -1; // -1 means current weather
    
    // Weather functionality
    // Wind speeds from the chosen Open-Meteo endpoint are requested in mph
    // so we treat values as mph throughout.
    
    const getWindDirection = (deg) => {
      const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
      return directions[Math.round(deg / 45) % 8];
    };
    
    const getConditions = (windSpeedMph, windDeg) => {
      let condition, conditionClass, location;
      
      // Determine condition based on wind speed
      if (windSpeedMph < 5) {
        condition = 'Great';
        conditionClass = 'conditions-great';
      } else if (windSpeedMph < 10) {
        condition = 'Good';
        conditionClass = 'conditions-good';
      } else if (windSpeedMph < 15) {
        condition = 'Reasonable';
        conditionClass = 'conditions-reasonable';
      } else if (windSpeedMph < 20) {
        condition = 'Marginal';
        conditionClass = 'conditions-marginal';
      } else {
        condition = 'Dont bother';
        conditionClass = 'conditions-bad';
      }
      
      // Determine location based on wind direction
      const direction = getWindDirection(windDeg);
      if (direction === 'E' || direction === 'NE' || direction === 'SE') {
        location = 'East Shore';
      } else if (direction === 'W' || direction === 'NW' || direction === 'SW') {
        location = 'West Shore';
      } else if (direction === 'S') {
        location = 'The Bay';
      } else {
        location = "Its up to you";
      }
      
      return { condition, conditionClass, location };
    };
    
    const fetchWeather = async () => {
      const errorEl = document.getElementById('error');
      const weatherContainer = document.getElementById('weatherContainer');
      const emptyState = document.getElementById('emptyState');
      
      selectedDayIndex = -1; // Reset to current weather
      
      try {
        // Use the user-provided Open-Meteo URL (wind in mph)
        emptyState.style.display = 'block';
        const url = 'https://api.open-meteo.com/v1/forecast?latitude=54.594723&longitude=-3.14536&hourly=temperature_2m,wind_speed_10m,wind_gusts_10m,winddirection_10m,precipitation&wind_speed_unit=mph&timezone=auto';
        const resp = await fetch(url);
        if (resp.ok) {
          const j = await resp.json();
          const nowMs = Date.now();

          // find current hourly index (first entry at or after now)
          const times = j.hourly && j.hourly.time ? j.hourly.time : [];
          let idx = times.findIndex(t => new Date(t).getTime() >= nowMs);
          if (idx < 0) idx = 0;

          const getVal = (arr, i) => (Array.isArray(arr) && arr[i] !== undefined) ? arr[i] : 0;

          const current = {
            name: 'Keswick',
            sys: { country: 'GB' },
            main: { temp: getVal(j.hourly.temperature_2m, idx), humidity: 0 },
            weather: [{ description: '' }],
            rain: { '1h': getVal(j.hourly.precipitation, idx) },
            wind: { speed: getVal(j.hourly.wind_speed_10m, idx), deg: getVal(j.hourly.winddirection_10m, idx), gust: getVal(j.hourly.wind_gusts_10m, idx) }
          };

          // Build hourly array (next 12 hours)
          const hourly = [];
          for (let i = idx; i < Math.min(times.length, idx + 12); i++) {
            hourly.push({
              dt: Math.floor(new Date(times[i]).getTime() / 1000),
              wind_speed: getVal(j.hourly.wind_speed_10m, i),
              wind_gust: getVal(j.hourly.wind_gusts_10m, i) || getVal(j.hourly.wind_speed_10m, i),
              wind_deg: getVal(j.hourly.winddirection_10m, i),
              rain: { '1h': getVal(j.hourly.precipitation, i) }
            });
          }

          // Aggregate simple 5-day forecast from hourly (skip today)
          const byDay = {};
          for (let i = 0; i < times.length; i++) {
            const d = new Date(times[i]);
            const dayKey = d.toISOString().slice(0,10); // YYYY-MM-DD
            if (!byDay[dayKey]) byDay[dayKey] = { temps: [], prec: 0, wind: [], gust: [] };
            byDay[dayKey].temps.push(getVal(j.hourly.temperature_2m, i));
            byDay[dayKey].prec += getVal(j.hourly.precipitation, i);
            byDay[dayKey].wind.push(getVal(j.hourly.wind_speed_10m, i));
            byDay[dayKey].gust.push(getVal(j.hourly.wind_gusts_10m, i) || getVal(j.hourly.wind_speed_10m, i));
          }

          const todayKey = new Date().toISOString().slice(0,10);
          const dayKeys = Object.keys(byDay).filter(k => k !== todayKey).slice(0,5);
          const forecast = dayKeys.map(k => {
            const entry = byDay[k];
            const maxTemp = Math.max(...entry.temps);
            const maxWind = Math.max(...entry.wind);
            const maxGust = Math.max(...entry.gust);
            const precSum = Math.round(entry.prec * 100) / 100;
            const dt = Math.floor(new Date(k + 'T12:00:00').getTime() / 1000);
            return { dt, main: { temp: maxTemp }, rain: { '3h': precSum }, wind: { speed: maxWind, deg: 0, gust: maxGust } };
          });

          weatherData = { current, forecast, hourly };
          // store full hourly series so we can show per-day hourly charts
          const allHourly = times.map((t, i) => ({
            dt: Math.floor(new Date(t).getTime() / 1000),
            wind_speed: getVal(j.hourly.wind_speed_10m, i),
            wind_gust: getVal(j.hourly.wind_gusts_10m, i) || getVal(j.hourly.wind_speed_10m, i),
            wind_deg: getVal(j.hourly.winddirection_10m, i),
            rain: { '1h': getVal(j.hourly.precipitation, i) }
          }));
          weatherData = { current, forecast, hourly, allHourly };
          emptyState.style.display = 'none';
          displayWeather(weatherData);
          return;
        } else {
          console.warn('Open-Meteo returned', resp.status);
          weatherData = null;
        }
      } catch (err) {
        console.warn('Open-Meteo fetch failed', err);
        weatherData = null;
      }

      // Fallback: if no real data supplied, show a small demo so UI isn't empty.
      if (!weatherData) {
        const now = Math.floor(Date.now()/1000);
        const demoHourly = [];
        for (let i=0;i<12;i++) {
          // generate plausible mph values for demo
          const ws = +(5 + Math.abs(Math.sin(i/2))*10 + (Math.random()*2-1)).toFixed(1);
          const gust = +(ws * (1.2 + Math.random()*0.6)).toFixed(1);
          const rainVal = Math.random() < 0.25 ? +(Math.random()*3).toFixed(2) : 0;
          demoHourly.push({ dt: now + i*3600, wind_speed: ws, wind_gust: gust, wind_deg: Math.floor(Math.random()*360), rain: {'1h': rainVal} });
        }

        weatherData = {
          current: {
            name: 'Keswick', sys: { country: 'GB' }, main: { temp: 12.5, humidity: 72 },
            weather: [{ description: 'partly cloudy' }], rain: {'1h': 0.2}, wind: { speed: 8.6, deg: 225, gust: 12 }
          },
          forecast: [
            { dt: now + 86400, main: { temp: 14.2 }, rain: {'3h': 1.5}, wind: { speed: 12.1, deg: 180, gust: 14 } },
            { dt: now + 172800, main: { temp: 11.8 }, rain: {'3h': 0}, wind: { speed: 6.2, deg: 270, gust: 8 } },
            { dt: now + 259200, main: { temp: 13.5 }, rain: {'3h': 2.8}, wind: { speed: 15.3, deg: 135, gust: 20 } },
            { dt: now + 345600, main: { temp: 15.1 }, rain: {'3h': 0.5}, wind: { speed: 9.9, deg: 90, gust: 12 } },
            { dt: now + 432000, main: { temp: 16.3 }, rain: {'3h': 0}, wind: { speed: 7.8, deg: 315, gust: 10 } }
          ],
          hourly: demoHourly,
          allHourly: demoHourly
        };

        emptyState.style.display = 'none';
        displayWeather(weatherData);
      }
    };
    
    const selectDay = (index) => {
      selectedDayIndex = index;
      displayWeather(weatherData);
    };
    
    const drawWindGraph = (windSpeedMph, windDeg) => {
      const canvas = document.createElement('canvas');
      canvas.width = 120;
      canvas.height = 120;
      const ctx = canvas.getContext('2d');
      
      const centerX = 60;
      const centerY = 60;
      const radius = 45;
      
      // Draw circle background
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
      ctx.stroke();
      
      // Draw cardinal directions
      ctx.fillStyle = '#000000';
      ctx.font = '10px "IBM Plex Mono"';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('N', centerX, centerY - radius - 10);
      ctx.fillText('S', centerX, centerY + radius + 10);
      ctx.fillText('E', centerX + radius + 10, centerY);
      ctx.fillText('W', centerX - radius - 10, centerY);
      
      // Draw wind arrow
      const angleRad = (windDeg - 90) * Math.PI / 180;
      const arrowLength = radius * 0.7;
      const endX = centerX + Math.cos(angleRad) * arrowLength;
      const endY = centerY + Math.sin(angleRad) * arrowLength;
      
      ctx.strokeStyle = '#000000';
      ctx.fillStyle = '#000000';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(endX, endY);
      ctx.stroke();
      
      // Draw arrowhead
      const headLen = 10;
      const angle1 = angleRad + Math.PI / 6;
      const angle2 = angleRad - Math.PI / 6;
      ctx.beginPath();
      ctx.moveTo(endX, endY);
      ctx.lineTo(endX - headLen * Math.cos(angle1), endY - headLen * Math.sin(angle1));
      ctx.lineTo(endX - headLen * Math.cos(angle2), endY - headLen * Math.sin(angle2));
      ctx.closePath();
      ctx.fill();
      
      return canvas.toDataURL();
    };
    
    const displayWeather = (data) => {
      const container = document.getElementById('weatherContainer');
      const conditionsBanner = document.getElementById('conditionsBanner');
      
      // Determine which day to show in detail
      let detailData, detailLabel;
      if (selectedDayIndex === -1) {
        detailData = data.current;
        detailLabel = 'Current Weather';
      } else {
        detailData = data.forecast[selectedDayIndex];
        const date = new Date(detailData.dt * 1000);
        detailLabel = date.toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric' });
      }
      
      // Helpers to compute averages (circular mean for direction)
      const avg = (arr) => arr.length ? arr.reduce((s, v) => s + v, 0) / arr.length : 0;
      const avgDirection = (degArr) => {
        if (!degArr || !degArr.length) return 0;
        let sx = 0, sy = 0;
        degArr.forEach(d => {
          const r = d * Math.PI / 180;
          sx += Math.cos(r);
          sy += Math.sin(r);
        });
        let a = Math.atan2(sy, sx) * 180 / Math.PI;
        if (a < 0) a += 360;
        return Math.round(a);
      };

      // Default values from detailData
      let windSpeedMph = detailData.wind.speed || 0;
      let windGustMph = detailData.wind.gust ? detailData.wind.gust : (windSpeedMph * 1.5);
      let windDeg = detailData.wind.deg || 0;

      // If a forecast day is selected, derive metrics from the day's 08:00-10:59 hourly window
      if (selectedDayIndex !== -1 && data.allHourly && data.allHourly.length && data.forecast && data.forecast[selectedDayIndex]) {
        const selDay = new Date(data.forecast[selectedDayIndex].dt * 1000);
        const dayKey = selDay.toISOString().slice(0,10);
        const windowHours = data.allHourly.filter(h => {
          const d = new Date(h.dt * 1000);
          const key = d.toISOString().slice(0,10);
          const hr = d.getHours();
          return key === dayKey && hr >= 8 && hr < 11;
        });
        if (windowHours.length) {
          windSpeedMph = +(avg(windowHours.map(h => h.wind_speed))).toFixed(1);
          windGustMph = +(Math.max(...windowHours.map(h => h.wind_gust || h.wind_speed))).toFixed(1);
          windDeg = avgDirection(windowHours.map(h => (h.wind_deg !== undefined ? h.wind_deg : (h.wind_dir_deg || 0))));
          // if hourly entries don't contain explicit deg, try to use forecast deg if present
          if (!windDeg && data.forecast[selectedDayIndex].wind && data.forecast[selectedDayIndex].wind.deg) {
            windDeg = data.forecast[selectedDayIndex].wind.deg;
          }
        }
      }

      // Use gusting value to decide conditions/banner
      const { condition, conditionClass, location } = getConditions(windGustMph, windDeg);
      const windGraphUrl = drawWindGraph(windSpeedMph, windDeg);

      // Build banner HTML to embed inside the main container (placed to the right of location)
      const bannerHtml = `
        <div style="display:flex;gap:12px;align-items:center;justify-content:flex-end;">
          <div class="conditions-banner ${conditionClass}" style="padding:10px 14px;min-width:140px;">
            <div style="font-weight:800;text-align:center">${condition.toUpperCase()}</div>
            <div style="font-size:0.85rem;opacity:0.95;text-align:center">${location}</div>
          </div>
          <div style="color:#e1e4e1;font-weight:700;font-size:0.9rem;white-space:nowrap;">
            ${windSpeedMph.toFixed(1)} mph · gust ${windGustMph.toFixed(1)} · ${getWindDirection(windDeg)}
          </div>
        </div>
      `;
      
      const html = `
        <div class="weather-container">
          <div class="current-weather">
            <div class="current-header">
              <div>
                <div class="location" style="display:flex;align-items:center;gap:8px;">
                  <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path>
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path>
                  </svg>
                  <h2 style="margin:0">Keswick, GB</h2>
                </div>
                <div style="font-size: 0.75rem; margin-top:6px; opacity: 0.9;">${detailLabel}</div>
              </div>
              <div id="conditionsBanner">${bannerHtml}</div>
            </div>
            
            <div style="display: grid; grid-template-columns: 120px 1fr; gap: 12px; align-items: center;">
              <img src="${windGraphUrl}" alt="Wind graph" style="width: 120px; height: 120px;">
              
              <div class="current-grid" style="grid-template-columns: repeat(2, 1fr);">
                <div class="metric">
                  <svg class="metric-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 15a4 4 0 004 4h9a5 5 0 10-.1-9.999 5.002 5.002 0 10-9.78 2.096A4.001 4.001 0 003 15z"></path>
                  </svg>
                  <div class="metric-label">Temp</div>
                  <div class="metric-value">${Math.round(detailData.main.temp)}°C</div>
                  ${selectedDayIndex === -1 ? `<div class="metric-sub">${detailData.weather[0].description}</div>` : ''}
                </div>
                
                <div class="metric">
                  <svg class="metric-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707"></path>
                  </svg>
                  <div class="metric-label">Rain</div>
                  <div class="metric-value">${selectedDayIndex === -1 ? (detailData.rain && detailData.rain['1h'] || 0) : (detailData.rain && detailData.rain['3h'] || 0)} mm</div>
                  ${selectedDayIndex === -1 ? `<div class="metric-sub">Hum: ${detailData.main.humidity}%</div>` : ''}
                </div>
                
                <div class="metric">
                  <div class="metric-icon" style="font-size: 16px; color: #000000;">→</div>
                  <div class="metric-label">Direction</div>
                  <div class="metric-value">${getWindDirection(windDeg)}</div>
                  <div class="metric-sub">${windDeg}°</div>
                </div>
                
                <div class="metric">
                  <svg class="metric-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path>
                  </svg>
                  <div class="metric-label">Speed</div>
                  <div class="metric-value">${windSpeedMph.toFixed(1)} mph</div>
                </div>
              </div>
            </div>
          </div>
          
          <div id="forecastsWrapper" style="display: block;">
            <div style="margin-top:8px;">
              <canvas id="hourlyChart" height="240" style="width:100%;height:240px;display:block;background:rgba(255,255,255,0.02);"></canvas>
            </div>

            <h3 class="forecast-header">5-Day Forecast</h3>
            <div class="forecast-grid">
            ${data.forecast.map(function(day, idx) {
              const date = new Date(day.dt * 1000);
              const rain = (day.rain && day.rain['3h']) || (day.snow && day.snow['3h']) || 0;
              const isSelected = idx === selectedDayIndex;
              const dayWindMph = day.wind.speed;
              // compute day direction from allHourly (08:00-10:59) when available
              let dayDeg = day.wind.deg || 0;
              if (data.allHourly && data.allHourly.length) {
                const dayKey = date.toISOString().slice(0,10);
                const fh = data.allHourly.filter(h => {
                  const d = new Date(h.dt * 1000);
                  const key = d.toISOString().slice(0,10);
                  const hr = d.getHours();
                  return key === dayKey && hr >= 8 && hr < 11;
                });
                if (fh.length) dayDeg = avgDirection(fh.map(h => h.wind_deg || 0));
              }
              const cond = getConditions(dayWindMph, dayDeg);
              return `
                <div class="forecast-day ${cond.conditionClass}" onclick="selectDay(${idx})" style="cursor: pointer; ${isSelected ? 'outline: 2px solid #e1e4e1; outline-offset: -2px;' : ''}">
                  <div class="day-name">${date.toLocaleDateString('en-US', { weekday: 'short' })}</div>
                  <div class="day-date">${date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}</div>
                  <div class="day-temp">${Math.round(day.main.temp)}°</div>
                  <div class="day-detail">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707"></path>
                    </svg>
                    <span>${rain}mm</span>
                  </div>
                  <div class="day-detail">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path>
                    </svg>
                    <span>${dayWindMph.toFixed(1)}mph ${getWindDirection(dayDeg)}</span>
                  </div>
                </div>
              `;
            }).join('')}
          </div>

        </div>
      `;
      
      container.innerHTML = html;
      // Render hourly chart: use the selected day's hourly slice when possible
      try {
        let chartHourly = data.hourly;
        if (selectedDayIndex !== -1 && data.allHourly && data.allHourly.length && data.forecast && data.forecast[selectedDayIndex]) {
          const selectedDay = new Date(data.forecast[selectedDayIndex].dt * 1000);
          const dayKey = selectedDay.toISOString().slice(0,10);
          const filtered = data.allHourly.filter(h => new Date(h.dt * 1000).toISOString().slice(0,10) === dayKey);
          if (filtered.length) chartHourly = filtered;
        }
        if (chartHourly && chartHourly.length) renderHourlyChart(chartHourly);
      } catch (e) {
        console.warn('Hourly chart render failed', e);
      }

      // forecasts always visible (toggle removed)
    };

    const renderHourlyChart = (hourly) => {
      // Ensure Chart is available
      if (typeof Chart === 'undefined') {
        const parent = document.getElementById('hourlyChart')?.parentElement;
        if (parent) parent.innerHTML = '<div style="color:#fff;padding:8px;background:#811;">Chart.js not loaded</div>';
        return;
      }

      // Register annotation plugin if available under common globals
      const plugin = window.ChartAnnotation || window.chartjsPluginAnnotation || window['chartjs-plugin-annotation'];
      if (plugin) {
        try { Chart.register(plugin); } catch (e) { console.warn('Annotation plugin register failed', e); }
      }

      const labels = hourly.map(h => {
        const d = new Date(h.dt * 1000);
        return d.getHours().toString().padStart(2,'0') + ':00';
      });

      const windConst = hourly.map(h => +(h.wind_speed).toFixed(1));
      const windGust = hourly.map(h => +(h.wind_gust || h.wind_speed).toFixed(1));
      const rain = hourly.map(h => +(h.rain && h.rain['1h'] ? h.rain['1h'] : 0));

      const canvas = document.getElementById('hourlyChart');
      if (!canvas) return;
      canvas.style.display = 'block';
      canvas.width = canvas.clientWidth;
      canvas.height = 240;
      const ctx = canvas.getContext('2d');

      const config = {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [
            {
              type: 'line',
              label: 'Wind',
              data: windConst,
              borderColor: '#0b84ff',
              backgroundColor: 'rgba(11,132,255,0.15)',
              yAxisID: 'yWind',
              tension: 0.3,
              pointRadius: 2
            },
            {
              type: 'line',
              label: 'Gust',
              data: windGust,
              borderColor: '#ff7f0e',
              backgroundColor: 'rgba(255,127,14,0.12)',
              yAxisID: 'yWind',
              tension: 0.3,
              pointRadius: 2
            },
            {
              type: 'bar',
              label: 'Rain',
              data: rain,
              backgroundColor: 'rgba(45,85,200,0.6)',
              yAxisID: 'yRain'
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: 'index', intersect: false },
          stacked: false,
          scales: {
            x: { display: true, title: { display: true, text: 'Hour' } },
            yWind: {
              type: 'linear',
              position: 'left',
              title: { display: true, text: 'Wind (mph)' }
            },
            yRain: {
              type: 'linear',
              position: 'right',
              title: { display: true, text: 'Rain (mm)' },
              grid: { drawOnChartArea: false }
            }
          },
          plugins: {
            legend: { position: 'top' },
            annotation: {
              annotations: {
                line_20: {
                  type: 'line',
                  scaleID: 'yWind',
                  value: 20,
                  borderColor: '#ff0000',
                  borderWidth: 4,
                  label: {
                    enabled: true,
                    content: '20 mph',
                    position: 'start',
                    font: { weight: 'bold' }
                  }
                }
              }
            }
          }
        }
      };

      try {
        // If an existing chart instance exists, destroy it first.
        if (window.hourlyChart && typeof window.hourlyChart.destroy === 'function') {
          try { window.hourlyChart.destroy(); } catch (e) { /* ignore */ }
          window.hourlyChart = null;
        }
        window.hourlyChart = new Chart(ctx, config);
      } catch (err) {
        console.error('Chart render error', err);
        const parent = canvas.parentElement;
        if (parent) parent.insertAdjacentHTML('beforeend', '<div style="color:#fff;padding:8px;background:#811;margin-top:6px;">Chart render failed</div>');
      }
    };
    
    // Load on start
    fetchWeather();
  </script>
</body>
</html>